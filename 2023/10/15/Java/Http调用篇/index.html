
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title> | Hexo</title>
    <meta name="author" content="shenkefeng" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>HEXO</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;HEXO</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/10/15
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="Http调用篇"><a href="#Http调用篇" class="headerlink" title="Http调用篇"></a>Http调用篇</h1><h2 id="1-超时"><a href="#1-超时" class="headerlink" title="1. 超时"></a>1. 超时</h2><p>对于 HTTP 调用，虽然应用层走的是 HTTP 协议，但网络层面始终是 TCP&#x2F;IP 协议。TCP&#x2F;IP 是面向连接的协议，在传输数据之前需要建立连接。几乎所有的网络框架都会提供这么两个超时参数。</p>
<h3 id="1-1-连接超时"><a href="#1-1-连接超时" class="headerlink" title="1.1 连接超时"></a>1.1 连接超时</h3><p>连接超时参数( <code>ConnectTimeout</code>): 让用户配置建连阶段的最长等待时间</p>
<p><strong>误区</strong>：</p>
<ol>
<li><p>连接超时配置得特别长，比如 60 秒。</p>
<p>一般而言，TCP三次握手的时间非常的短，如果很久没有建立连接，很可能是网络或防火墙的问题。如果几秒连接不上，可能永远也连接不上。所以连接超时时间设置特别长意义不大，1~5s即可。</p>
</li>
<li><p>排查连接超时问题，却没理清连的是哪里。</p>
<p>一般而言，服务端会有很多个节点，如果通过客户端负载均衡，那么是直接与服务端建立连接，如果服务端是通过Nginx的反向代理来负载均衡，那么是与Nginx建立连接。</p>
</li>
</ol>
<ul>
<li>直接连接服务端（排查服务端的问题）</li>
<li>连接Nginx（排查Nginx的问题）</li>
</ul>
<h3 id="1-2-读取超时"><a href="#1-2-读取超时" class="headerlink" title="1.2 读取超时"></a>1.2 读取超时</h3><p>读取超时参数(<code>ReadTimeout</code>): 用来控制从 <code>Socket</code> 上读取数据的最长等待时间。</p>
<p><strong>误区</strong>：</p>
<ol>
<li><p>出现了读取超时，服务端的执行就会中断。</p>
<pre><code class="java">@RestController
@RequestMapping(&quot;clientreadtimeout&quot;)
@Slf4j
public class ClientReadTimeoutController &#123;

    private String getResponse(String url, int connectTimeout, int readTimeout) throws IOException &#123;
        return Request.Get(&quot;http://localhost:8080/clientreadtimeout&quot; + url)
                .connectTimeout(connectTimeout)
                .socketTimeout(readTimeout)
                .execute()
                .returnContent()
                .asString();
    &#125;

    @GetMapping(&quot;client&quot;)
    public String client() throws IOException &#123;
        log.info(&quot;client1 called&quot;);
        //服务端5s超时，客户端读取超时2秒
        return getResponse(&quot;/server?timeout=5000&quot;, 1000, 2000);
    &#125;

    @GetMapping(&quot;server&quot;)
    public void server(@RequestParam(&quot;timeout&quot;) int timeout) throws InterruptedException &#123;
        log.info(&quot;server called&quot;);
        TimeUnit.MILLISECONDS.sleep(timeout);
        log.info(&quot;Done&quot;);
    &#125;
&#125;
</code></pre>
<p>调用 client 接口后，从日志中可以看到，客户端 2 秒后出现了 <code>SocketTimeoutException</code>，原因是读取超时，服务端却丝毫没受影响在 3 秒后执行完成。</p>
<p>类似 Tomcat 的 Web 服务器都是把服务端请求提交到线程池处理的，只要服务端收到了请求，网络层面的超时和断开便不会影响服务端的执行。<strong>因此，出现读取超时不能随意假设服务端的处理情况，需要根据业务状态考虑如何进行后续处理。</strong></p>
</li>
<li><p>认为读取超时只是 Socket 网络层面的概念，是数据传输的最长耗时，故将其配置得非常短，比如 100 毫秒。</p>
<p>确切地说，读取超时指的是，向 Socket 写入数据后，我们等到 Socket 返回数据的超时时间，其中包含的时间或者说绝大部分的时间，是<code>服务端处理业务逻辑的时间</code>。</p>
</li>
<li><p>认为超时时间越长任务接口成功率就越高，将读取超时参数配置得太长。</p>
<p>HTTP请求一般是需要获得结果，属于同步调用。当服务端处理时间过长，客户端的线程（Tomcat线程）一直处于等待状态，当出现大量超时时，并发情况下可能会创建大量的线程，最终导致程序崩溃。我们应该设置一个较短的读取超时时间，以防止被下游服务拖慢，<code>通常不会设置超过 30 秒的读取超时。</code></p>
<p>对定时任务或异步任务来说，读取超时配置得长些问题不大</p>
</li>
</ol>
<h3 id="1-3-Feign-和-Ribbon-配合使用，你知道怎么配置超时吗？"><a href="#1-3-Feign-和-Ribbon-配合使用，你知道怎么配置超时吗？" class="headerlink" title="1.3 Feign 和 Ribbon 配合使用，你知道怎么配置超时吗？"></a>1.3 Feign 和 Ribbon 配合使用，你知道怎么配置超时吗？</h3><p>为Feign 配置超时参数比较复杂，为 Feign 配置超时参数的复杂之处在于，Feign 自己有两个超时参数，它使用的负载均衡组件 Ribbon 本身还有相关配置。</p>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><h5 id="结论一：Feign和Ribbon都不设置，默认情况下取Ribbon的读取超时-1-秒，如此短的读取超时算是坑点一。"><a href="#结论一：Feign和Ribbon都不设置，默认情况下取Ribbon的读取超时-1-秒，如此短的读取超时算是坑点一。" class="headerlink" title="结论一：Feign和Ribbon都不设置，默认情况下取Ribbon的读取超时 1 秒，如此短的读取超时算是坑点一。"></a>结论一：Feign和Ribbon都不设置，默认情况下取Ribbon的读取超时 1 秒，如此短的读取超时算是坑点一。</h5><pre><code class="java">public class RibbonClientConfiguration &#123;
    // ... 
    /**
     * Ribbon client default connect timeout.
     */
    public static final int DEFAULT_CONNECT_TIMEOUT = 1000;

    /**
     * Ribbon client default read timeout.
     */
    public static final int DEFAULT_READ_TIMEOUT = 1000;
    @Bean
     @ConditionalOnMissingBean
     public IClientConfig ribbonClientConfig() &#123;
        DefaultClientConfigImpl config = new DefaultClientConfigImpl();
        config.loadProperties(this.name);
        config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);
        config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);
        config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);
        return config;
    &#125;
&#125;
</code></pre>
<h5 id="结论二：如果要配置-Feign-的读取超时，就必须同时配置连接超时，才能生效。-我看源码的时候已经修复了"><a href="#结论二：如果要配置-Feign-的读取超时，就必须同时配置连接超时，才能生效。-我看源码的时候已经修复了" class="headerlink" title="结论二：如果要配置 Feign 的读取超时，就必须同时配置连接超时，才能生效。(&#x3D;&#x3D;我看源码的时候已经修复了&#x3D;&#x3D;)"></a>结论二：如果要配置 Feign 的读取超时，就必须同时配置连接超时，才能生效。(&#x3D;&#x3D;我看源码的时候已经修复了&#x3D;&#x3D;)</h5><pre><code class="java">if (config.getConnectTimeout() != null &amp;&amp; config.getReadTimeout() != null) &#123;
   builder.options(new Request.Options(config.getConnectTimeout(),
         config.getReadTimeout()));
&#125;
</code></pre>
<p>&#x3D;&#x3D;Feign创建Request时，如果获取连接超时时间或者读取超时时间未配置会取默认值。&#x3D;&#x3D;</p>
<pre><code class="java">class FeignClientFactoryBean
        implements FactoryBean&lt;Object&gt;, InitializingBean, ApplicationContextAware &#123;
    // 其中创建Options时默认连接超时时间为10s，读取超时时间为60s
    private int readTimeoutMillis = new Request.Options().readTimeoutMillis();
     private int connectTimeoutMillis = new Request.Options().connectTimeoutMillis();

    protected void configureUsingProperties(FeignClientProperties.FeignClientConfiguration config,
            Feign.Builder builder)&#123;
        connectTimeoutMillis = config.getConnectTimeout() != null
                ? config.getConnectTimeout() : connectTimeoutMillis;
        readTimeoutMillis = config.getReadTimeout() != null ? config.getReadTimeout()
                : readTimeoutMillis;

        builder.options(new Request.Options(connectTimeoutMillis, TimeUnit.MILLISECONDS,
                readTimeoutMillis, TimeUnit.MILLISECONDS, true));
    &#125;
&#125;
</code></pre>
<h5 id="结论三：单独的超时可以覆盖全局超时，这符合预期。"><a href="#结论三：单独的超时可以覆盖全局超时，这符合预期。" class="headerlink" title="结论三：单独的超时可以覆盖全局超时，这符合预期。"></a>结论三：单独的超时可以覆盖全局超时，这符合预期。</h5><p>对单独的 Feign Client 设置超时时间，可以把 default 替换为 Client 的 name：</p>
<pre><code class="properties">feign.client.config.default.readTimeout=3000
feign.client.config.default.connectTimeout=3000
feign.client.config.clientsdk.readTimeout=2000
feign.client.config.clientsdk.connectTimeout=2000
</code></pre>
<h5 id="结论四：除了可以配置-Feign，也可以配置-Ribbon-组件的参数来修改两个超时时间。"><a href="#结论四：除了可以配置-Feign，也可以配置-Ribbon-组件的参数来修改两个超时时间。" class="headerlink" title="结论四：除了可以配置 Feign，也可以配置 Ribbon 组件的参数来修改两个超时时间。"></a>结论四：除了可以配置 Feign，也可以配置 Ribbon 组件的参数来修改两个超时时间。</h5><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：首字母需大写</p>
<pre><code class="properties">ribbon.ReadTimeout=4000
ribbon.ConnectTimeout=4000
</code></pre>
<h5 id="结论五：同时配置-Feign-和-Ribbon-的超时，以-Feign-为准。"><a href="#结论五：同时配置-Feign-和-Ribbon-的超时，以-Feign-为准。" class="headerlink" title="结论五：同时配置 Feign 和 Ribbon 的超时，以 Feign 为准。"></a>结论五：同时配置 Feign 和 Ribbon 的超时，以 Feign 为准。</h5><pre><code class="properties">feign.client.config.default.readTimeout=3000
feign.client.config.default.connectTimeout=3000
ribbon.ReadTimeout=4000
ribbon.ConnectTimeout=4000
</code></pre>
<pre><code> 执行耗时：3006ms 错误：Read timed out executing POST http://clientsdk/feignandribbon/server
</code></pre>
<pre><code class="java">public class LoadBalancerFeignClient implements Client &#123;
    IClientConfig getClientConfig(Request.Options options, String clientName) &#123;
        IClientConfig requestConfig;
        if (options == DEFAULT_OPTIONS) &#123; // false 
            requestConfig = this.clientFactory.getClientConfig(clientName);
        &#125;
        else &#123;
            requestConfig = new FeignOptionsClientConfig(options);
        &#125;
        return requestConfig;
    &#125;
&#125;
</code></pre>
<h2 id="2-重试"><a href="#2-重试" class="headerlink" title="2. 重试"></a>2. 重试</h2><h3 id="2-1-Ribbon-会自动重试请求"><a href="#2-1-Ribbon-会自动重试请求" class="headerlink" title="2.1 Ribbon 会自动重试请求"></a>2.1 Ribbon 会自动重试请求</h3><pre><code class="java">// DefaultClientConfigImpl
// 同一个服务其他实例的最大重试次数，不包括第一次调用的实例。默认值为1
public static final int DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER = 1;
// 同一实例最大重试次数，不包括首次调用。默认值为0
public static final int DEFAULT_MAX_AUTO_RETRIES = 0;
// 是否所有操作都允许重试。默认值为false
public static final Boolean DEFAULT_OK_TO_RETRY_ON_ALL_OPERATIONS = Boolean.FALSE;

// RibbonLoadBalancedRetryPolicy
public boolean canRetry(LoadBalancedRetryContext context) &#123;

   HttpMethod method = context.getRequest().getMethod();
   return HttpMethod.GET == method || lbContext.isOkToRetryOnAllOperations();
&#125;

@Override
public boolean canRetrySameServer(LoadBalancedRetryContext context) &#123;

   return sameServerCount &lt; lbContext.getRetryHandler().getMaxRetriesOnSameServer()
         &amp;&amp; canRetry(context);

&#125;

@Override
public boolean canRetryNextServer(LoadBalancedRetryContext context) &#123;

   // this will be called after a failure occurs and we increment the counter
   // so we check that the count is less than or equals to too make sure
   // we try the next server the right number of times
   return nextServerCount &lt;= lbContext.getRetryHandler().getMaxRetriesOnNextServer()
         &amp;&amp; canRetry(context);
&#125;
</code></pre>
<h2 id="3-并发"><a href="#3-并发" class="headerlink" title="3. 并发"></a>3. 并发</h2><p>defaultMaxPerRoute&#x3D;2，也就是同一个主机 &#x2F; 域名的最大并发请求数为 2</p>
<h2 id="4-项目"><a href="#4-项目" class="headerlink" title="4. 项目"></a>4. 项目</h2><p><img src="https://oss-picgo-skf.oss-cn-hangzhou.aliyuncs.com/ob/img/image-20231015160832329.png" alt="image-20231015160832329"></p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Hexo
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;shenkefeng
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
